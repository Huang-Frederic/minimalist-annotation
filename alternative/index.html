<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            background-color: #121212;
            color: #E0E0E0;
            font-family: Arial, sans-serif;
        }

        button {
            background-color: #333;
            color: #FFF;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #555;
        }

        #canvasContainer {
            position: relative;
            width: 90%;
            max-width: 900px;
            height: 80vh;
            margin: auto;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <input type="file" id="folderInput" webkitdirectory directory multiple>
    <button id="toggleModeButton">Switch to Bounding Box Mode</button>
    <button id="prevButton" class="hidden">Previous</button>
    <button id="nextButton" class="hidden">Next</button>
    <button id="resetViewButton" class="hidden">Reset View</button>
    <button id="clearButton" class="hidden">Clear</button>
    <button id="undoButton" class="hidden">Undo</button>
    <button id="downloadButton" class="hidden">Save</button>
    <div id="canvasContainer">
        <canvas id="imageCanvas"></canvas>
        <canvas id="annCanvas"></canvas>
        <canvas id="tmpCanvas"></canvas>
        <canvas id="crosshairCanvas"></canvas>
    </div>

    <script>
        let imageFiles = [];
        let currentIndex = 0;
        let annotations = [];
        let imageCanvas = document.getElementById('imageCanvas');
        let crosshairCanvas = document.getElementById('crosshairCanvas');
        let annCanvas = document.getElementById('annCanvas');
        let tmpCanvas = document.getElementById('tmpCanvas');
        let imageCtx = imageCanvas.getContext('2d');
        let crosshairCtx = crosshairCanvas.getContext('2d');
        let annCtx = annCanvas.getContext('2d');
        let tmpCtx = tmpCanvas.getContext('2d');
        let currentImage = null;
        let margin = 20; // Margin around the image
        let dragging = false;
        let lastX = 0;
        let lastY = 0;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;
        const rs = 5;  // radius of the square representing the point
        let annotationMode = 'point';  // or 'bbox'
        let bboxStart = null;
        let drawingBbox = false;


        document.getElementById('folderInput').addEventListener('change', function (event) {
            const files = event.target.files;
            imageFiles = [];
            annotations = [];

            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    imageFiles.push(file);
                    annotations.push([]);
                }
            }

            if (imageFiles.length > 0) {
                document.getElementById('folderInput').style.display = 'none';
                document.getElementById('prevButton').classList.remove('hidden');
                document.getElementById('nextButton').classList.remove('hidden');
                document.getElementById('resetViewButton').classList.remove('hidden');
                document.getElementById('clearButton').classList.remove('hidden');
                document.getElementById('undoButton').classList.remove('hidden');
                document.getElementById('downloadButton').classList.remove('hidden');
                document.getElementById('imageCanvas').classList.remove('hidden');
                document.getElementById('crosshairCanvas').classList.remove('hidden');
                document.getElementById('annCanvas').classList.remove('hidden');
                document.getElementById('tmpCanvas').classList.remove('hidden');
                showImage();
            } else {
                alert('No images found in the folder.');
            }
        });

        document.getElementById('toggleModeButton').addEventListener('click', function() {
            if (annotationMode === 'point') {
                annotationMode = 'bbox';
                this.textContent = 'Switch to Point Mode';
            } else {
                annotationMode = 'point';
                this.textContent = 'Switch to Bounding Box Mode';
            }
        });

        document.getElementById('nextButton').addEventListener('click', function () {
            if (currentIndex < imageFiles.length - 1) {
                currentIndex++;
                showImage();
            }
        });

        document.getElementById('prevButton').addEventListener('click', function () {
            if (currentIndex > 0) {
                currentIndex--;
                showImage();
            }
        });

        document.getElementById('resetViewButton').addEventListener('click', function () {
            resetView();
            drawPoints();
        });

        document.getElementById('clearButton').addEventListener('click', function () {
            annotations[currentIndex] = [];
            drawPoints();
        });
    
        document.getElementById('undoButton').addEventListener('click', function () {
            annotations[currentIndex].pop();
            drawPoints();
        });

        document.getElementById('downloadButton').addEventListener('click', function () {
            downloadAnnotations();
        });

        function downloadAnnotations() {
            let annotationsToDownload = {};
            imageFiles.forEach((file, index) => {
                if (annotations[index] && annotations[index].length > 0) { // Only include images with annotations
                    annotationsToDownload[file.name] = annotations[index];
                }
            });

            // Convert the annotations object to a JSON string
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(annotationsToDownload));
            let downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "annotations.json");
            document.body.appendChild(downloadAnchorNode); // Required for Firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }


        // mouse move
        crosshairCanvas.addEventListener('mousemove', function (event) {
            drawCrosshair(event.offsetX, event.offsetY);
            clicking = false;  // mouse moved, not a click
            if (drawingBbox) {
                tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                tmpCtx.strokeStyle = 'violet';
                tmpCtx.lineWidth = 4;
                let x1 = Math.min(event.offsetX, bboxStart.x * scale + translateX);
                let y1 = Math.min(event.offsetY, bboxStart.y * scale + translateY);
                let x2 = Math.max(event.offsetX, bboxStart.x * scale + translateX);
                let y2 = Math.max(event.offsetY, bboxStart.y * scale + translateY);
                tmpCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }
            if (dragging) {
                let dx = event.offsetX - lastX;
                let dy = event.offsetY - lastY;
                translateX += dx;
                translateY += dy;
                lastX = event.offsetX;
                lastY = event.offsetY;
                drawPoints();
            }
        });


        window.addEventListener('contextmenu', function (event) {
            console.log('contextmenu window')
            event.preventDefault();
        })

        // click
        crosshairCanvas.addEventListener('mousedown', function (event) {
            clicking = true;
            if (event.button === 0) { // Check if left mouse button is pressed
                dragging = true;
                lastX = event.offsetX;
                lastY = event.offsetY;
            }
        });

        crosshairCanvas.addEventListener('mouseup', function (event) {
            if (clicking) {
                if (event.button === 0) { // Ensure the left mouse button was released
                    if (annotationMode === 'point') {
                        addPoint((event.offsetX - translateX) / scale, (event.offsetY - translateY) / scale, 'positive');
                    } else if (annotationMode === 'bbox') {
                        if (!bboxStart) {
                            // First click sets the start of the bounding box
                            bboxStart = { x: (event.offsetX - translateX) / scale, y: (event.offsetY - translateY) / scale };
                            drawingBbox = true;
                        } else {
                            // Second click sets the end of the bounding box and creates it
                            addBoundingBox(bboxStart, { x: (event.offsetX - translateX) / scale, y: (event.offsetY - translateY) / scale });
                            bboxStart = null;  // Reset for next bounding box
                            drawingBbox = false;
                        }
                    
                    }
                }
                if (event.button === 2) { // Ensure the right mouse button was released
                    if (annotationMode === 'point') {
                        addPoint((event.offsetX - translateX) / scale, (event.offsetY - translateY) / scale, 'negative');
                    } else if (annotationMode === 'bbox') {
                        // Right click does nothing in bbox mode
                        bboxStart = null;
                        drawingBbox = false;
                        tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                    }
                }
                clicking = false;
            }

        });

        window.addEventListener('mouseup', function (event) {
            if (event.button === 0) { // Ensure the left mouse button was released
                dragging = false;
            }
        });

        crosshairCanvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            const zoomSpeed = 0.05;
            let delta = -Math.sign(event.deltaY) * zoomSpeed;
            let zoomFactor = Math.exp(delta);
            scale *= zoomFactor;

            // translation comes from the equality (tx - eo) / s1 = (tx2 - eo) / s2 which means that the relative position of eo wrt tx should be constant
            translateX = (translateX - event.offsetX) * zoomFactor + event.offsetX
            translateY = (translateY - event.offsetY) * zoomFactor + event.offsetY
            drawPoints();
        })

        function addPoint(x, y, type) {
            console.log('Adding point at', x, y, type);
            // Save the annotation
            annotations[currentIndex].push({
                imgX: x,
                imgY: y,
                type: type,
            });
            console.log(annotations[currentIndex])



            drawPoints(); // Update the canvas with new point
        }

        function addBoundingBox(start, end) {
            let bbox = {
                x1: Math.min(start.x, end.x),
                y1: Math.min(start.y, end.y),
                x2: Math.max(start.x, end.x),
                y2: Math.max(start.y, end.y),
                type: 'bbox'
            };
            annotations[currentIndex].push(bbox);
            drawPoints();
        }


        function drawPoints() {
            tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
            annCtx.clearRect(0, 0, annCanvas.width, annCanvas.height);
            drawImage(); // Redraw the image first

            annotations[currentIndex].forEach(ann => {
                if (ann.type === 'bbox') {
                    annCtx.strokeStyle = 'green';
                    annCtx.lineWidth = 4;
                    let x1 = ann.x1 * scale + translateX;
                    let y1 = ann.y1 * scale + translateY;
                    let x2 = ann.x2 * scale + translateX;
                    let y2 = ann.y2 * scale + translateY;
                    annCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                } else {
                    if (ann.type === 'positive') {
                        annCtx.fillStyle = 'green';
                    } else if (ann.type === 'negative') {
                        annCtx.fillStyle = 'red';
                    } 
                    let x = ann.imgX * scale + translateX;
                    let y = ann.imgY * scale + translateY;
                    annCtx.fillRect(x - rs, y - rs, 2 * rs + 1, 2 * rs + 1);
                }
            });
        }



        function applyClamping() {
            translateX = Math.max(Math.min(imageCanvas.width - margin, translateX), margin - currentImage.width * scale)
            translateY = Math.max(Math.min(imageCanvas.height - margin, translateY), margin - currentImage.height * scale)
        }

        function drawImage() {
            imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            applyClamping()
            imageCtx.drawImage(currentImage, translateX, translateY, currentImage.width * scale, currentImage.height * scale);
        }

        function drawCrosshair(x, y) {
            crosshairCtx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);
            crosshairCtx.strokeStyle = 'red';
            crosshairCtx.beginPath();
            crosshairCtx.moveTo(x, 0);
            crosshairCtx.lineTo(x, crosshairCanvas.height);
            crosshairCtx.moveTo(0, y);
            crosshairCtx.lineTo(crosshairCanvas.width, y);
            crosshairCtx.stroke();
        }
        function resetView() {
            let maxCanvasWidth = imageCanvas.width - 2 * margin;
            let maxCanvasHeight = imageCanvas.height - 2 * margin;
            scale = Math.min(maxCanvasWidth / currentImage.width, maxCanvasHeight / currentImage.height);
            translateX = (imageCanvas.width - currentImage.width * scale) / 2;
            translateY = (imageCanvas.height - currentImage.height * scale) / 2;
        }

        function showImage() {
            if (currentIndex >= 0 && currentIndex < imageFiles.length) {
                const fileReader = new FileReader();
                fileReader.onload = function (e) {
                    currentImage = new Image();
                    currentImage.onload = () => {
                        imageCanvas.width = crosshairCanvas.width = annCanvas.width = tmpCanvas.width = canvasContainer.clientWidth;
                        imageCanvas.height = crosshairCanvas.height = annCanvas.height = tmpCanvas.height = canvasContainer.clientHeight;

                        // Reset zoom and translation
                        resetView()

                        drawPoints();
                    };
                    currentImage.src = e.target.result;
                };
                fileReader.readAsDataURL(imageFiles[currentIndex]);
            } else {
                alert('Index out of bounds. This should not happen.');
            }
        }
    </script>

</body>

</html>