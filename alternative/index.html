<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            background-color: #121212;
            color: #E0E0E0;
            font-family: Arial, sans-serif;
        }

        button {
            background-color: #333;
            color: #FFF;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #555;
        }

        #canvasContainer {
            position: relative;
            width: 90%;
            max-width: 1024px;
            height: 80vh;
            margin: auto;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>

    <button id="selectFolderButton" style="font-size: large; padding: 15px 30px;">Select Folder</button>
    <input type="file" id="folderInput" class="hidden" webkitdirectory directory multiple>
    <input type="file" id="loadFileInput" class="hidden" accept=".json">
    <div id="buttonContainer">
        <button id="toggleModeButton" class="hidden">Switch to Bounding Box Mode</button>
        <button id="prevButton" class="hidden">Previous</button>
        <button id="nextButton" class="hidden">Next</button>
        <button id="resetViewButton" class="hidden">Reset View</button>
        <button id="clearButton" class="hidden">Clear</button>
        <button id="undoButton" class="hidden">Undo</button>
        <button id="downloadButton" class="hidden">Save Annotations</button>
        <button id="loadAnnotationsButton" class="hidden">Load Annotations</button>
    </div>
    <div id="canvasContainer" class="hidden">
        <canvas id="imageCanvas"></canvas>
        <canvas id="annCanvas"></canvas>
        <canvas id="tmpCanvas"></canvas>
        <canvas id="crosshairCanvas"></canvas>
    </div>
    <input type="text" id="annotationDescription" class="hidden">

    <script>
        let imageFiles = [];
        let currentIndex = 0;
        let annotations = {};
        let imageCanvas = document.getElementById('imageCanvas');
        let crosshairCanvas = document.getElementById('crosshairCanvas');
        let annCanvas = document.getElementById('annCanvas');
        let tmpCanvas = document.getElementById('tmpCanvas');
        let imageCtx = imageCanvas.getContext('2d');
        let crosshairCtx = crosshairCanvas.getContext('2d');
        let annCtx = annCanvas.getContext('2d');
        let tmpCtx = tmpCanvas.getContext('2d');
        let currentImage = null;
        let margin = 20; // Margin around the image
        let dragging = false;
        let lastX = 0;
        let lastY = 0;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;
        const rs = 5;  // radius of the square representing the point
        let annotationMode = 'point';  // or 'bbox'
        let bboxStart = null;
        let drawingBbox = false;
        let navigationActive = true;
        let currentFile = null;

        document.getElementById('selectFolderButton').addEventListener('click', function () {
            document.getElementById('folderInput').click();
        });

        document.addEventListener('keydown', function (event) {
            if (navigationActive && (event.key === 'a' || event.key === 'A' || event.key === 'ArrowLeft')) {
                // Simulate a click on the "Previous" button
                document.getElementById('prevButton').click();
            } else if (navigationActive && (event.key === 'd' || event.key === 'D' || event.key === 'ArrowRight')) {
                // Simulate a click on the "Next" button
                document.getElementById('nextButton').click();
            }
        });

        document.getElementById('folderInput').addEventListener('change', function (event) {
            const files = event.target.files;
            imageFiles = [];
            annotations = {};

            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    imageFiles.push(file);
                }
            }

            if (imageFiles.length > 0) {
                document.getElementById('selectFolderButton').style.display = 'none';
                document.getElementById('prevButton').classList.remove('hidden');
                document.getElementById('nextButton').classList.remove('hidden');
                document.getElementById('resetViewButton').classList.remove('hidden');
                document.getElementById('clearButton').classList.remove('hidden');
                document.getElementById('undoButton').classList.remove('hidden');
                document.getElementById('downloadButton').classList.remove('hidden');
                document.getElementById('toggleModeButton').classList.remove('hidden');
                document.getElementById('canvasContainer').classList.remove('hidden');
                document.getElementById('annotationDescription').classList.remove('hidden');
                document.getElementById('loadAnnotationsButton').classList.remove('hidden');
                showImage();
            } else {
                alert('No images found in the folder.');
            }
        });

        document.getElementById('loadAnnotationsButton').addEventListener('click', function() {
            document.getElementById('loadFileInput').click();  // Trigger file selection
        });

        document.getElementById('loadFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file && file.type === "application/json") {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const loadedAnnotations = JSON.parse(e.target.result);
                        if (typeof loadedAnnotations === "object") {
                            annotations = loadedAnnotations;
                            renderAnnotations();  // Update the canvas with loaded annotations
                            alert('Annotations loaded successfully.');
                        } else {
                            throw new Error('Format is not correct');
                        }
                    } catch (err) {
                        alert('Failed to load annotations: ' + err.message);
                    }
                };
                reader.readAsText(file);
            } else {
                alert('Please select a valid JSON file.');
            }
            this.value = '';  // Reset the input after the file is loaded
        });

        document.getElementById('toggleModeButton').addEventListener('click', function () {
            if (annotationMode === 'point') {
                annotationMode = 'bbox';
                this.textContent = 'Switch to Point Mode';
            } else {
                annotationMode = 'point';
                this.textContent = 'Switch to Bounding Box Mode';
            }
        });

        document.getElementById('nextButton').addEventListener('click', function () {
            if (currentIndex < imageFiles.length - 1) {
                currentIndex++;
                showImage();
            }
        });

        document.getElementById('prevButton').addEventListener('click', function () {
            if (currentIndex > 0) {
                currentIndex--;
                showImage();
            }
        });

        document.getElementById('resetViewButton').addEventListener('click', function () {
            resetView();
            renderAnnotations();
        });

        document.getElementById('clearButton').addEventListener('click', function () {
            annotations[currentFile] = [];
            renderAnnotations();
        });

        document.getElementById('undoButton').addEventListener('click', function () {
            annotations[currentFile].pop();
            renderAnnotations();
        });

        document.getElementById('downloadButton').addEventListener('click', function () {
            downloadAnnotations();
        });

        document.getElementById('annotationDescription').addEventListener('focus', function () {
            // remove previous description
            navigationActive = false;
            annotations[currentFile] = annotations[currentFile].filter(ann => ann.type !== 'desc');
        });
        document.getElementById('annotationDescription').addEventListener('blur', function () {
            annotations[currentFile].push({
                type: 'desc',
                description: this.value
            });
            renderAnnotations();
            navigationActive = true;
        });

        function downloadAnnotations() {
            // Convert the annotations object to a JSON string
            let dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(annotations));
            let downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "annotations.json");
            document.body.appendChild(downloadAnchorNode); // Required for Firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }


        // mouse move
        crosshairCanvas.addEventListener('mousemove', function (event) {
            drawCrosshair(event.offsetX, event.offsetY);
            clicking = false;  // mouse moved, not a click
            if (drawingBbox) {
                tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                tmpCtx.strokeStyle = 'violet';
                tmpCtx.lineWidth = 4;
                let x1 = Math.min(event.offsetX, bboxStart.x * scale + translateX);
                let y1 = Math.min(event.offsetY, bboxStart.y * scale + translateY);
                let x2 = Math.max(event.offsetX, bboxStart.x * scale + translateX);
                let y2 = Math.max(event.offsetY, bboxStart.y * scale + translateY);
                tmpCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }
            if (dragging) {
                let dx = event.offsetX - lastX;
                let dy = event.offsetY - lastY;
                translateX += dx;
                translateY += dy;
                lastX = event.offsetX;
                lastY = event.offsetY;
                renderAnnotations();
            }
        });


        window.addEventListener('contextmenu', function (event) {
            console.log('contextmenu window')
            event.preventDefault();
        })

        // click
        crosshairCanvas.addEventListener('mousedown', function (event) {
            clicking = true;
            if (event.button === 0) { // Check if left mouse button is pressed
                dragging = true;
                lastX = event.offsetX;
                lastY = event.offsetY;
            }
        });

        crosshairCanvas.addEventListener('mouseup', function (event) {
            if (clicking) {
                if (event.button === 0) { // Ensure the left mouse button was released
                    if (annotationMode === 'point') {
                        addPoint((event.offsetX - translateX) / scale, (event.offsetY - translateY) / scale, 'positive');
                    } else if (annotationMode === 'bbox') {
                        if (!bboxStart) {
                            // First click sets the start of the bounding box
                            bboxStart = { x: (event.offsetX - translateX) / scale, y: (event.offsetY - translateY) / scale };
                            drawingBbox = true;
                        } else {
                            // Second click sets the end of the bounding box and creates it
                            addBoundingBox(bboxStart, { x: (event.offsetX - translateX) / scale, y: (event.offsetY - translateY) / scale });
                            bboxStart = null;  // Reset for next bounding box
                            drawingBbox = false;
                        }

                    }
                }
                if (event.button === 2) { // Ensure the right mouse button was released
                    if (annotationMode === 'point') {
                        addPoint((event.offsetX - translateX) / scale, (event.offsetY - translateY) / scale, 'negative');
                    } else if (annotationMode === 'bbox') {
                        // Right click does nothing in bbox mode
                        bboxStart = null;
                        drawingBbox = false;
                        tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
                    }
                }
                clicking = false;
            }

        });

        window.addEventListener('mouseup', function (event) {
            if (event.button === 0) { // Ensure the left mouse button was released
                dragging = false;
            }
        });

        crosshairCanvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            const zoomSpeed = 0.05;
            let delta = -Math.sign(event.deltaY) * zoomSpeed;
            let zoomFactor = Math.exp(delta);
            scale *= zoomFactor;

            // translation comes from the equality (tx - eo) / s1 = (tx2 - eo) / s2 which means that the relative position of eo wrt tx should be constant
            translateX = (translateX - event.offsetX) * zoomFactor + event.offsetX
            translateY = (translateY - event.offsetY) * zoomFactor + event.offsetY
            renderAnnotations();
        })

        function addPoint(x, y, type) {
            console.log('Adding point at', x, y, type);
            // Save the annotation
            annotations[currentFile].push({
                imgX: x,
                imgY: y,
                type: type,
            });
            renderAnnotations(); // Update the canvas with new point
        }

        function addBoundingBox(start, end) {
            let bbox = {
                x1: Math.min(start.x, end.x),
                y1: Math.min(start.y, end.y),
                x2: Math.max(start.x, end.x),
                y2: Math.max(start.y, end.y),
                type: 'bbox'
            };
            annotations[currentFile].push(bbox);
            renderAnnotations();
        }


        function renderAnnotations() {
            tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
            annCtx.clearRect(0, 0, annCanvas.width, annCanvas.height);
            drawImage(); // Redraw the image first

            let deleteDescription = true;
            annotations[currentFile].forEach(ann => {
                if (ann.type === 'bbox') {
                    annCtx.strokeStyle = 'green';
                    annCtx.lineWidth = 4;
                    let x1 = ann.x1 * scale + translateX;
                    let y1 = ann.y1 * scale + translateY;
                    let x2 = ann.x2 * scale + translateX;
                    let y2 = ann.y2 * scale + translateY;
                    annCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                } else if (ann.type === 'desc') {
                    deleteDescription = false;
                    document.getElementById('annotationDescription').value = ann.description;
                } else {
                    if (ann.type === 'positive') {
                        annCtx.fillStyle = 'green';
                    } else if (ann.type === 'negative') {
                        annCtx.fillStyle = 'red';
                    }
                    let x = ann.imgX * scale + translateX;
                    let y = ann.imgY * scale + translateY;
                    annCtx.fillRect(x - rs, y - rs, 2 * rs + 1, 2 * rs + 1);
                }
            });
            if (deleteDescription) {
                document.getElementById('annotationDescription').value = '';
            }
        }



        function applyClamping() {
            translateX = Math.max(Math.min(imageCanvas.width - margin, translateX), margin - currentImage.width * scale)
            translateY = Math.max(Math.min(imageCanvas.height - margin, translateY), margin - currentImage.height * scale)
        }

        function drawImage() {
            imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            applyClamping()
            imageCtx.drawImage(currentImage, translateX, translateY, currentImage.width * scale, currentImage.height * scale);
        }

        function drawCrosshair(x, y) {
            crosshairCtx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);
            crosshairCtx.strokeStyle = 'red';
            crosshairCtx.beginPath();
            crosshairCtx.moveTo(x, 0);
            crosshairCtx.lineTo(x, crosshairCanvas.height);
            crosshairCtx.moveTo(0, y);
            crosshairCtx.lineTo(crosshairCanvas.width, y);
            crosshairCtx.stroke();
        }
        function resetView() {
            let maxCanvasWidth = imageCanvas.width - 2 * margin;
            let maxCanvasHeight = imageCanvas.height - 2 * margin;
            scale = Math.min(maxCanvasWidth / currentImage.width, maxCanvasHeight / currentImage.height);
            translateX = (imageCanvas.width - currentImage.width * scale) / 2;
            translateY = (imageCanvas.height - currentImage.height * scale) / 2;
        }

        function showImage() {
            if (currentIndex >= 0 && currentIndex < imageFiles.length) {
                currentFile = imageFiles[currentIndex].name;
                annotations[currentFile] = annotations[currentFile] || [];
                const fileReader = new FileReader();
                fileReader.onload = function (e) {
                    currentImage = new Image();
                    currentImage.onload = () => {
                        imageCanvas.width = crosshairCanvas.width = annCanvas.width = tmpCanvas.width = canvasContainer.clientWidth;
                        imageCanvas.height = crosshairCanvas.height = annCanvas.height = tmpCanvas.height = canvasContainer.clientHeight;

                        // Reset zoom and translation
                        resetView()

                        renderAnnotations();
                    };
                    currentImage.src = e.target.result;
                };
                fileReader.readAsDataURL(imageFiles[currentIndex]);
            } else {
                alert('Index out of bounds. This should not happen.');
            }
        }
    </script>

</body>

</html>