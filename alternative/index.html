<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            background-color: #121212;
            color: #E0E0E0;
            font-family: Arial, sans-serif;
        }

        button {
            background-color: #333;
            color: #FFF;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #555;
        }

        #canvasContainer {
            position: relative;
            width: 90%;
            max-width: 900px;
            height: 80vh;
            margin: auto;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <input type="file" id="folderInput" webkitdirectory directory multiple>
    <button id="prevButton" class="hidden">Previous</button>
    <button id="nextButton" class="hidden">Next</button>
    <div id="canvasContainer">
        <canvas id="imageCanvas"></canvas>
        <canvas id="clickCanvas"></canvas>
        <canvas id="crosshairCanvas"></canvas>
    </div>

    <script>
        let imageFiles = [];
        let currentIndex = 0;
        let annotations = [];
        let imageCanvas = document.getElementById('imageCanvas');
        let crosshairCanvas = document.getElementById('crosshairCanvas');
        let clickCanvas = document.getElementById('clickCanvas');
        let imageCtx = imageCanvas.getContext('2d');
        let crosshairCtx = crosshairCanvas.getContext('2d');
        let clickCtx = clickCanvas.getContext('2d');
        let currentImage = null;
        let margin = 20; // Margin around the image
        let dragging = false;
        let lastX = 0;
        let lastY = 0;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;
        const rs = 2;  // radius of the square representing the point

        document.getElementById('folderInput').addEventListener('change', function (event) {
            const files = event.target.files;
            imageFiles = [];
            annotations = [];

            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    imageFiles.push(file);
                    annotations.push([]);
                }
            }

            if (imageFiles.length > 0) {
                document.getElementById('folderInput').style.display = 'none';
                document.getElementById('prevButton').classList.remove('hidden');
                document.getElementById('nextButton').classList.remove('hidden');
                document.getElementById('imageCanvas').classList.remove('hidden');
                document.getElementById('crosshairCanvas').classList.remove('hidden');
                document.getElementById('clickCanvas').classList.remove('hidden');
                showImage();
            } else {
                alert('No images found in the folder.');
            }
        });

        document.getElementById('nextButton').addEventListener('click', function () {
            if (currentIndex < imageFiles.length - 1) {
                currentIndex++;
                showImage();
            }
        });

        document.getElementById('prevButton').addEventListener('click', function () {
            if (currentIndex > 0) {
                currentIndex--;
                showImage();
            }
        });

        // mouse move
        crosshairCanvas.addEventListener('mousemove', function (event) {
            drawCrosshair(event.offsetX, event.offsetY);
            clicking = false;  // mouse moved, not a click
            if (dragging) {
                let dx = event.offsetX - lastX;
                let dy = event.offsetY - lastY;
                translateX += dx;
                translateY += dy;
                lastX = event.offsetX;
                lastY = event.offsetY;
                drawPoints();
            }
        });

        // click
        crosshairCanvas.addEventListener('mousedown', function (event) {
            clicking = true;
            if (event.button === 0) { // Check if left mouse button is pressed
                dragging = true;
                lastX = event.offsetX;
                lastY = event.offsetY;
            }
        });

        crosshairCanvas.addEventListener('mouseup', function (event) {
            if (clicking) {
                if (event.button === 0) { // Ensure the left mouse button was released
                    addPoint((event.offsetX - translateX) / scale, (event.offsetY - translateY) / scale, 'positive');
                }
                if (event.button === 2) { // Ensure the right mouse button was released
                    event.preventDefault(); // Prevent the context menu
                    addPoint(currentImage.width * (event.offsetX - translateX) / scale, currentImage.height * (event.offsetY - translateY) / scale, 'negative');
                }
                clicking = false;
            }

        });

        window.addEventListener('mouseup', function (event) {
            if (event.button === 0) { // Ensure the left mouse button was released
                dragging = false;
            }
        });

        crosshairCanvas.addEventListener("wheel", function (event) {
            event.preventDefault();
            const zoomSpeed = 0.05;
            let delta = -Math.sign(event.deltaY) * zoomSpeed;
            let zoomFactor = Math.exp(delta);
            scale *= zoomFactor;

            // translation comes from the equality (tx - eo) / s1 = (tx2 - eo) / s2 which means that the relative position of eo wrt tx should be constant
            translateX = (translateX - event.offsetX) * zoomFactor + event.offsetX
            translateY = (translateY - event.offsetY) * zoomFactor + event.offsetY
            drawPoints();
        })

        function addPoint(x, y, type) {
            console.log('Adding point at', x, y, type);
            // Save the annotation
            annotations[currentIndex].push({
                imgX: x,
                imgY: y,
                type: type,
            });
            console.log(annotations[currentIndex])



            drawPoints(); // Update the canvas with new point
        }

        function drawPoints() {
            clickCtx.clearRect(0, 0, clickCanvas.width, clickCanvas.height);
            drawImage(); // Redraw the image first

            annotations[currentIndex].forEach(point => {
                if (point.type === 'positive') {
                    clickCtx.fillStyle = 'green';
                } else {
                    clickCtx.fillStyle = 'red';
                }
                let x = point.imgX * scale + translateX;
                let y = point.imgY * scale + translateY;
                clickCtx.fillRect(x - rs, y - rs, 2 * rs + 1, 2 * rs + 1);
            });
        }



        function applyClamping() {
            translateX = Math.max(Math.min(imageCanvas.width - margin, translateX), margin - currentImage.width * scale)
            translateY = Math.max(Math.min(imageCanvas.height - margin, translateY), margin - currentImage.height * scale)
        }

        function drawImage() {
            imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            applyClamping()
            imageCtx.drawImage(currentImage, translateX, translateY, currentImage.width * scale, currentImage.height * scale);
        }

        function drawCrosshair(x, y) {
            crosshairCtx.clearRect(0, 0, crosshairCanvas.width, crosshairCanvas.height);
            crosshairCtx.strokeStyle = 'red';
            crosshairCtx.beginPath();
            crosshairCtx.moveTo(x, 0);
            crosshairCtx.lineTo(x, crosshairCanvas.height);
            crosshairCtx.moveTo(0, y);
            crosshairCtx.lineTo(crosshairCanvas.width, y);
            crosshairCtx.stroke();
        }

        function showImage() {
            if (currentIndex >= 0 && currentIndex < imageFiles.length) {
                const fileReader = new FileReader();
                fileReader.onload = function (e) {
                    currentImage = new Image();
                    currentImage.onload = () => {
                        imageCanvas.width = crosshairCanvas.width = clickCanvas.width = canvasContainer.clientWidth;
                        imageCanvas.height = crosshairCanvas.height = clickCanvas.height = canvasContainer.clientHeight;

                        // Reset zoom and translation
                        translateX = 0; // Reset translation to center image
                        translateY = 0;
                        let maxCanvasWidth = imageCanvas.width - 2 * margin;
                        let maxCanvasHeight = imageCanvas.height - 2 * margin;
                        scale = Math.min(maxCanvasWidth / currentImage.width, maxCanvasHeight / currentImage.height);
                        translateX = (imageCanvas.width - currentImage.width * scale) / 2;
                        translateY = (imageCanvas.height - currentImage.height * scale) / 2;
                        drawImage();
                    };
                    currentImage.src = e.target.result;
                };
                fileReader.readAsDataURL(imageFiles[currentIndex]);
            } else {
                alert('Index out of bounds. This should not happen.');
            }
        }
    </script>

</body>

</html>